perc = myProbs,
coefs = rowMeans(myruns_matrix),
se = apply(myruns_matrix, 1, sd),
.name_repair = ~ vctrs::vec_as_names(..., quiet = TRUE)
) %>% print()
} else { # for event study results
max_e <- myRuns[[1]]$name_runs %>%
mutate(diff = qteYear - qteCohort) %>%
pull(diff) %>%
max()
if (periods_es > max_e) periods_es <- max_e
myBoot <- lapply(0:periods_es, function(e) {
myCoefs_es <- map(map(myRuns, 1), e + 1)
myruns_matrix_es <- lapply(myCoefs_es, function(x) x[(names(x) %in% c("values"))]) %>% bind_cols(.name_repair = ~ vctrs::vec_as_names(..., quiet = TRUE))
# aggregate the bootstrap runs
myNames <- c("perc", paste0("coefs_", e), paste0("se_", e))
temp <- tibble(
perc = myProbs,
coefs = rowMeans(myruns_matrix_es),
se = apply(myruns_matrix_es, 1, sd),
.name_repair = ~ vctrs::vec_as_names(..., quiet = TRUE)
)
names(temp) <- myNames
return(temp)
})
print(myBoot)
}
# combine the outputs files
if(save_to_disk == T){
myRuns <- lapply(1:2, function(j){
list(
coefs =  lapply(list.files( path = paste0(pathData, "temp/"), pattern = paste0("myQuant", j, ".rds"), full.names = TRUE ), readRDS)[[1]],
name_runs =   lapply(list.files( path = paste0(pathData, "temp/"), pattern = paste0("name_runs", j, ".rds"), full.names = TRUE ), readRDS)[[1]]
)})
}
################################################################################
# Bootstrap Results
if (es == F) { # for average QTEs
myCoefs <- map(myRuns, 1) # extract the coefficients from output list
myruns_matrix <- lapply(myCoefs, function(x) x[(names(x) %in% c("values"))]) %>% bind_cols(.name_repair = ~ vctrs::vec_as_names(..., quiet = TRUE))
# aggregate the bootstrap runs
myBoot <- tibble(
perc = myProbs,
coefs = rowMeans(myruns_matrix),
se = apply(myruns_matrix, 1, sd),
.name_repair = ~ vctrs::vec_as_names(..., quiet = TRUE)
) %>% print()
} else { # for event study results
max_e <- myRuns[[1]]$name_runs %>%
mutate(diff = qteYear - qteCohort) %>%
pull(diff) %>%
max()
if (periods_es > max_e) periods_es <- max_e
myBoot <- lapply(0:periods_es, function(e) {
myCoefs_es <- map(map(myRuns, 1), e + 1)
myruns_matrix_es <- lapply(myCoefs_es, function(x) x[(names(x) %in% c("values"))]) %>% bind_cols(.name_repair = ~ vctrs::vec_as_names(..., quiet = TRUE))
# aggregate the bootstrap runs
myNames <- c("perc", paste0("coefs_", e), paste0("se_", e))
temp <- tibble(
perc = myProbs,
coefs = rowMeans(myruns_matrix_es),
se = apply(myruns_matrix_es, 1, sd),
.name_repair = ~ vctrs::vec_as_names(..., quiet = TRUE)
)
names(temp) <- myNames
return(temp)
})
print(myBoot)
}
myBoot
last_period
last_cohort
nReps
es
paste0(pathData, "results/", "birth", last_cohort, "_umsatz100_incAbove_boot", nReps, "_es", es")
paste0(pathData, "results/", "birth", last_cohort, "_umsatz100_incAbove_boot", nReps, "_es", es)
saveRDS(myBoot,
paste0(pathData, "results/", "birth", last_cohort, "_umsatz100_incAbove_boot", nReps, "_es", es, ".rds"))
nReps <- 1
boot <- F # do bootstrap or not? (then no SE)
nReps <- 1 # no. of bootstrap runs (set to 1 if no bootstrap!)
#-------------------------------------------------------------------------------
# extract groups
(last_cohort <- max(data_full %>% pull(get(cohortVar)), na.rm = T)) # cannot compute effects for the last cohort / group !
(qte_cohort <- head(data_full %>% pull(get(cohortVar)) %>% unique() %>% sort(), -1)) # the cohort for the treatment effect
# number of CICs to calculate
nRuns <- 0
for (g in 2:(last_cohort - 1)) {
nRuns <- nRuns + sum(1:(last_cohort - g)) * (g - 1)
}
# CHECK THE DATA AND SETTINGS
if (displayChecks == T) {
if (es == F) {
print(paste0("Started bootstrap for ", length(unique(data_full %>% pull(get(cohortVar)))) - 1, " groups and ", nrow(data_full), " observations (implying ", nRuns, " CIC regressions) with ", nReps, " bootstrap replication(s). Groups with less than ", nMin, " observations are deleted."))
print(paste0("Average QTEs are reported for ", length(myProbs), " percentiles."))
cat("\n")
} else {
print(paste0("Started bootstrap for ", length(unique(data_full %>% pull(get(cohortVar)))) - 1, " groups (", nRuns, " CIC regressions) with ", nReps, " bootstrap replication(s). Groups with less than ", nMin, " observations are deleted."))
print(paste0("Event Study QTEs are reported for ", periods_es, " periods and ", length(myProbs), "percentiles."))
cat("\n")
}
# empty groups?
result <- rle(diff(data_full %>% pull(get(cohortVar)) %>% unique() %>% sort()))
if (any(result$lengths >= 2 & result$values == 1) == F) {
print("WARNING: You have periods without treatments (before the dropping)!")
} else {
print("CHECK 1: All periods have some treated units (before dropping).")
}
# dropped groups?
group_sizes <- data_full %>%
distinct(id, .keep_all = T) %>%
count(get(cohortVar))
diffGroup <- data_full %>%
pull(get(cohortVar)) %>%
unique() %>%
length() - group_sizes %>%
mutate(check = n < nMin) %>%
summarize(false = sum(check == F), true = sum(check == T)) %>%
pull(false)
if (diffGroup != 0) {
print(paste0("WARNING: You have ", diffGroup, " too small groups! (", round(100 * diffGroup / data_full %>%
pull(get(cohortVar)) %>%
unique() %>%
length()), "%). They will be dropped."))
} else {
print("CHECK 2: No groups are dropped.")
}
}
myRuns
myRuns[[Â¦]]
myRuns
# combine the outputs files
if(save_to_disk == T){
myRuns <- lapply(1:100, function(j){
list(
coefs =  lapply(list.files( path = paste0(pathData, "temp/"), pattern = paste0("myQuant", j, ".rds"), full.names = TRUE ), readRDS)[[1]],
name_runs =   lapply(list.files( path = paste0(pathData, "temp/"), pattern = paste0("name_runs", j, ".rds"), full.names = TRUE ), readRDS)[[1]]
)})
}
################################################################################
# Bootstrap Results
if (es == F) { # for average QTEs
myCoefs <- map(myRuns, 1) # extract the coefficients from output list
myruns_matrix <- lapply(myCoefs, function(x) x[(names(x) %in% c("values"))]) %>% bind_cols(.name_repair = ~ vctrs::vec_as_names(..., quiet = TRUE))
# aggregate the bootstrap runs
myBoot <- tibble(
perc = myProbs,
coefs = rowMeans(myruns_matrix),
se = apply(myruns_matrix, 1, sd),
.name_repair = ~ vctrs::vec_as_names(..., quiet = TRUE)
) %>% print()
} else { # for event study results
max_e <- myRuns[[1]]$name_runs %>%
mutate(diff = qteYear - qteCohort) %>%
pull(diff) %>%
max()
if (periods_es > max_e) periods_es <- max_e
myBoot <- lapply(0:periods_es, function(e) {
myCoefs_es <- map(map(myRuns, 1), e + 1)
myruns_matrix_es <- lapply(myCoefs_es, function(x) x[(names(x) %in% c("values"))]) %>% bind_cols(.name_repair = ~ vctrs::vec_as_names(..., quiet = TRUE))
# aggregate the bootstrap runs
myNames <- c("perc", paste0("coefs_", e), paste0("se_", e))
temp <- tibble(
perc = myProbs,
coefs = rowMeans(myruns_matrix_es),
se = apply(myruns_matrix_es, 1, sd),
.name_repair = ~ vctrs::vec_as_names(..., quiet = TRUE)
)
names(temp) <- myNames
return(temp)
})
print(myBoot)
}
#-------------------------------------------------------------------------------
# plot the average QTEs
if (es == F) {
ggplot(myBoot, aes(x = perc, y = coefs)) +
geom_hline(yintercept = 0, col = "grey60") +
geom_ribbon(aes(ymin = coefs - 1.96 * se, ymax = coefs + 1.96 * se), alpha = .15) +
geom_line(linetype = "dashed", color = "grey50") +
geom_point(size = 2) +
# coord_cartesian(ylim = c(-1.5, .7)) +
theme_minimal() +
xlab("\n Percentiles") +
ylab("QTE \n")
} else {
# plot the event-study QTEs
myBoot_plot <- lapply(myBoot, function(x) x[!(names(x) %in% c("perc"))]) %>%
bind_cols() %>%
mutate(perc = myProbs) %>%
pivot_longer(
-perc,
names_to = c(".value", "e"),
names_sep = "_"
) %>%
dplyr::filter(perc %in% perc_plot)
ggplot(
myBoot_plot %>% mutate(e = as.numeric(e)),
aes(x = e, y = coefs, group = as_factor(perc), color = as_factor(perc))
) +
geom_hline(yintercept = 0) +
geom_errorbar(position = position_dodge(width = 0.3), aes(ymin = coefs - 1.96 * se, ymax = coefs + 1.96 * se), linewidth = 1, width = .4, alpha = .8) +
geom_line(position = position_dodge(width = 0.3), linetype = "dotted", linewidth = 1.3, alpha = .8) +
geom_point(size = 3, position = position_dodge(width = 0.3)) +
theme_minimal() +
scale_color_viridis_d(option = "plasma", begin = .2, end = .8) +
xlab("\n Months After the Treatment") +
ylab("QTE \n") +
labs(color = "Percentiles")
}
ggplot(myBoot, aes(x = perc, y = coefs)) +
geom_hline(yintercept = 0, col = "grey60") +
geom_ribbon(aes(ymin = coefs - 1.96 * se, ymax = coefs + 1.96 * se), alpha = .15) +
geom_line(linetype = "dashed", color = "grey50") +
geom_point(size = 2) +
coord_cartesian(ylim = c(-.5, 6)) +
theme_minimal() +
xlab("\n Percentiles") +
ylab("QTE \n")
ggplot(myBoot, aes(x = perc, y = coefs)) +
geom_hline(yintercept = 0, col = "grey60") +
geom_ribbon(aes(ymin = coefs - 1.96 * se, ymax = coefs + 1.96 * se), alpha = .15) +
geom_line(linetype = "dashed", color = "grey50") +
geom_point(size = 2) +
coord_cartesian(ylim = c(-1, 6)) +
theme_minimal() +
xlab("\n Percentiles") +
ylab("QTE \n")
myFolder <- "temp"
myFolder <- "temp" # folder to save the bootstrap runs
#-------------------------------------------------------------------------------
source("Code/R/Functions/mundlak_fct.R")
data(cars)
cars
cars %>% as_tibble()
data(mtcars)
mtcars
mtcars %>% as_tibble()
library(tidyverse)
mtcars %>% as_tibble()
#-------------------------------------------------------------------------------
source("B:/Uni-Due/Code/R/Functions/mundlak_fct.R")
library("did")
library("broom")
library("fixest")
library("ggplot2")
library("data.table")
library("magrittr")
library("tidyverse")
library("ggokabeito")
simulation6 = function() {
dat = CJ(firm = 1:10000, year = 1980:2015)     [
, time_fe := rnorm(1, sd = .5), by = "year"][
, unit_fe := rnorm(1, sd = .5), by = "firm"][
, state := sample(1:50, 1), by = "firm"    ]
setkey(dat, state, firm, year)
treatment_groups = data.table(
state = c(1, 18, 35),
cohort = c(1989, 1998, 2007),
#hat_gamma = c(.5, .2, .1)) # HETEROGENEITY
hat_gamma = .5) # NO HETEROGENEITY
dat = treatment_groups[dat, roll = TRUE, on = "state"][
, treat  := as.numeric(year >= cohort)          ][
, gamma  := rnorm(.N, mean = hat_gamma, sd = .2)][
, tau    := fifelse(treat == 1, gamma, 0)       ][
, x    :=  runif(.N)         ][
#, cumtau := cumsum(tau), by = "firm"            ][ # HETEROGENEITY
, cumtau := tau                                 ][ # NO HETEROGENEITY
, error  := rnorm(.N, 0, .5)                    ][
, yTrue := unit_fe + time_fe  + cumtau           ][
, y := unit_fe + time_fe + cumtau + error     ][
, time_to_treat := year - cohort     ]
return(dat)
}
# run the simulation
(dat = simulation6())
dat
dat %>% as_tibble()
simulation6 = function() {
dat = CJ(firm = 1:100, year = 1980:2015)     [
, time_fe := rnorm(1, sd = .5), by = "year"][
, unit_fe := rnorm(1, sd = .5), by = "firm"][
, state := sample(1:50, 1), by = "firm"    ]
setkey(dat, state, firm, year)
treatment_groups = data.table(
state = c(1, 18, 35),
cohort = c(1989, 1998, 2007),
#hat_gamma = c(.5, .2, .1)) # HETEROGENEITY
hat_gamma = .5) # NO HETEROGENEITY
dat = treatment_groups[dat, roll = TRUE, on = "state"][
, treat  := as.numeric(year >= cohort)          ][
, gamma  := rnorm(.N, mean = hat_gamma, sd = .2)][
, tau    := fifelse(treat == 1, gamma, 0)       ][
, x    :=  runif(.N)         ][
#, cumtau := cumsum(tau), by = "firm"            ][ # HETEROGENEITY
, cumtau := tau                                 ][ # NO HETEROGENEITY
, error  := rnorm(.N, 0, .5)                    ][
, yTrue := unit_fe + time_fe  + cumtau           ][
, y := unit_fe + time_fe + cumtau + error     ][
, time_to_treat := year - cohort     ]
return(dat)
}
# run the simulation
(dat = simulation6())
dat
dat %>% as_tibble()
etwfe(
y = "y", t = "year", g = "cohort", i = "firm", do_demean = T,
data = dat %>% as_tibble()
)
feols(y ~ treat | year + firm,
data %>% as_tibble() %>% mutate(treat = year >= cohort))
feols(y ~ treat | year + firm,
data %>% as_tibble() %>% mutate(treat = year >= cohort))
feols(y ~ treat | year + firm,
dat %>% as_tibble() %>% mutate(treat = year >= cohort))
# a standard pre/post DiD
feols(y ~ treat*x | year + firm,
dat %>% as_tibble() %>% mutate(treat = year >= cohort)
)
# Wooldridge
etwfe(
y = "y", t = "year", g = "cohort", i = "firm", do_demean = T, x = x,
data = dat %>% as_tibble()
)
# Wooldridge
etwfe(
y = "y", t = "year", g = "cohort", i = "firm", do_demean = T, x = "x",
data = dat %>% as_tibble()
)
# Wooldridge
etwfe(
y = "y", t = "year", g = "cohort", i = "firm", do_demean = F, x = "x",
data = dat %>% as_tibble()
)
# a standard pre/post DiD
feols(y ~ treat:x | year + firm,
dat %>% as_tibble() %>% mutate(treat = year >= cohort)
)
# a standard pre/post DiD
feols(y ~ treat:x | year + firm,
dat %>% as_tibble() %>% mutate(treat = as_factor(year >= cohort))
)
# a standard pre/post DiD
feols(y ~ i(treat):x | year + firm,
dat %>% as_tibble() %>% mutate(treat = as_factor(year >= cohort))
)
# a standard pre/post DiD
feols(y ~ treat*x | year + firm,
dat %>% as_tibble() %>% mutate(treat = as_factor(year >= cohort))
)
dat %>% as_tibble() %>% mutate(treat = ifelse(year >= cohort, 1, 0)
# a standard pre/post DiD
feols(y ~ treat*x | year + firm,
dat %>% as_tibble() %>% mutate(treat = ifelse(year >= cohort, 1, 0))
)
# Wooldridge
etwfe(
y = "y", t = "year", g = "cohort", i = "firm", do_demean = F, x = "x",
data = dat %>% as_tibble()
)
dat
saveRDS(dat, "Desktop:/dat.rds")
saveRDS(dat, "Desktop/dat.rds")
saveRDS(dat, "C:/Users/frkl.ECON/Desktop/dat.rds")
xlsx::write.xlsx(dat, "C:/Users/frkl.ECON/Desktop/dat.rds")
install.packages("xlsx")
xlsx::write.xlsx(dat, "C:/Users/frkl.ECON/Desktop/dat.xlsx")
# Wooldridge
etwfe(
y = "y", t = "year", g = "cohort", i = "firm", do_demean = F, x = NULL,
data = dat %>% as_tibble()
)
# a standard pre/post DiD
feols(y ~ treat | year + firm,
dat %>% as_tibble() %>% mutate(treat = ifelse(year >= cohort, 1, 0))
)
# a standard pre/post DiD
feols(y ~ treat*x | year + firm,
dat %>% as_tibble() %>% mutate(treat = ifelse(year >= cohort, 1, 0))
)
# Wooldridge
etwfe(
y = "y", t = "year", g = "cohort", i = "firm", do_demean = F, x = "x",
data = dat %>% as_tibble()
)
#-------------------------------------------------------------------------------
# This function runs all sensible combinations of 2x2-CiC regressions, saves
# the observed y1 and calculated y0, averages them, inverts them, and
# takes the difference of the quantile function.
# Standard errors are calculated by bootstrapping the entire process x-times
# in parallel computing.
#-------------------------------------------------------------------------------
# !! Nobody can be treated in the first period. No QTE calculated for the last
# treated group. !!
################################################################################
rm(list = ls())
gc()
pathCode <- "C:/Users/frkl.ECON/OneDrive - Universitaet Bern/PhD/CIC/CIC/"
pathData <- "C:/Users/frkl.ECON/OneDrive - Universitaet Bern/PhD/CIC/"
#-------------------------------------------------------------------------------
# load the QTE package of Callaway
source(paste0(pathCode, "load_functions.R"))
# install and load directly all the packages
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, fst, fixest, magrittr, BMisc, pbapply, foreach, parallel, tibble, dplyr, furrr, purrr, spatstat.geom, patchwork)
null <- NULL
#-------------------------------------------------------------------------------
# load the data
#sales_data <- read_fst(paste0(pathData, "sales_death.fst"), from = 1, to = NULL) %>%
sales_data <- read_fst("B:/Uni-Due/Data/BFS/sales_death.fst", from = 1, to = NULL) %>%
dplyr::filter(household_lastPeriod != household_death_lastPeriod, !is.na(code_final)) %>%
mutate(
period = tsibble::yearmonth(as.Date(period, origin = "1970-01-01")),
date = tsibble::yearmonth(as.Date(date, origin = "1970-01-01"))
) %>%
as_tibble() %>%
print()
install.packages("devtools")
install.packages("roxygen2")
devtools::create("myfirstpackage")
install.packages("roxygen2")
devtools::create("ecic")
devtools::create("C:/Users/frkl.ECON/Documents/GitHub/ecic")
devtools::document()
?document
rm(list = ls())
gc()
# PC
pathCode <- "C:/Users/frkl.ECON/OneDrive - Universitaet Bern/PhD/CIC/CIC/"
pathData <- "C:/Users/frkl.ECON/OneDrive - Universitaet Bern/PhD/CIC/"
#-------------------------------------------------------------------------------
# load the QTE package of Callaway
source(paste0(pathCode, "load_functions.R"))
# install and load directly all the packages
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, fst, fixest, magrittr, BMisc, pbapply, foreach, parallel, tibble, dplyr, furrr, purrr, spatstat.geom, patchwork, data.table)
simulation6 <- function(n = 100, t = 20) {
dat <- CJ(firm = 1:n, year = 1980:(1980+t-1))[
, time_fe := rnorm(1, sd = .5), by = "year"][
, unit_fe := rnorm(1, sd = .5), by = "firm"][
, xvar := sample(c(0:2), 1), by = "firm"][ # categorical (can be more than 2)
#, xvar := runif(n = 1, min = 0, max = 3), by = "firm"][ # continuous
, cohort := sample((1980):(1980+t-1), 1), by = "firm"]
setkey(dat, cohort, firm, year)
treatment_groups <- data.table(
cohort = c(1980:(1980+t)),
#hat_gamma = c(.5, .2, .1, 1, 2, 3)) # heterogeneity across cohorts
hat_gamma = 5) # no cohort heterogeneity
dat <- treatment_groups[dat, roll = TRUE, on = "cohort"][
, treat := as.numeric(year >= cohort)][
, gamma := rnorm(.N, mean = hat_gamma, sd = .2)][
, tau := fifelse(treat == 1, gamma, 0)][
#, cumtau := tau][ # no period heterogeneity
, cumtau := cumsum(tau), by = "firm"][ # heterogeneity across periods
, error := rnorm(.N, 0, .2)][
, y := unit_fe + time_fe + cumtau + xvar*cumtau + error][
, time_to_treat := year - cohort]
return(dat)
}
mpdta = simulation6(n = 10000, t = 5) %>% as_tibble() %>%
rename(lemp = y, first.treat = cohort, sex = xvar, countyreal = firm) %>% print()
myRuns <- ecic(yvar = "lemp", gvar = "first.treat", tvar = "year", ivar = "countyreal", es = F,
boot = "weighted", nReps = 3, nMin = 10, dat = mpdta, save_to_disk = F)
#########################################################
source("cic_fct.R")
#########################################################
source("C:/Users/frkl.ECON/Documents/GitHub/etwfe/R/cic_fct.R")
source("C:/Users/frkl.ECON/Documents/GitHub/etwfe/R/cic_plot.R")
#########################################################
source("C:/Users/frkl.ECON/Documents/GitHub/ecic/R/cic_fct.R")
source("C:/Users/frkl.ECON/Documents/GitHub/ecic/R/cic_plot.R")
source("C:/Users/frkl.ECON/Documents/GitHub/ecic/R/cic_results.R")
#########################################################
source("C:/Users/frkl.ECON/Documents/GitHub/ecic/R/cic_fct.R")
source("C:/Users/frkl.ECON/Documents/GitHub/ecic/R/cic_plot.R")
source("C:/Users/frkl.ECON/Documents/GitHub/ecic/R/cic_plot.R")
source("C:/Users/frkl.ECON/Documents/GitHub/ecic/R/cic_results.R")
myRuns <- ecic(yvar = "lemp", gvar = "first.treat", tvar = "year", ivar = "countyreal", es = F,
boot = "weighted", nReps = 3, nMin = 10, dat = mpdta, save_to_disk = F)
myBoot
myRuns
class(myRuns)
class(myRuns)[1]
devtools::check("C:/Users/frkl.ECON/Documents/GitHub/ecic")
?stop
?stop
devtools::check("C:/Users/frkl.ECON/Documents/GitHub/ecic")
?aggregate
myPlot
?sd
?aggregate
?multicore
?quantile
?furrr_options
devtools::check("C:/Users/frkl.ECON/Documents/GitHub/ecic")
use_mit_license()
devtools::check("C:/Users/frkl.ECON/Documents/GitHub/ecic")
devtools::check("C:/Users/frkl.ECON/Documents/GitHub/ecic")
devtools::check("C:/Users/frkl.ECON/Documents/GitHub/ecic")
use_mit_license()
?use_mit_license
usethis::use_mit_license
usethis::use_mit_license
usethis::use_mit_license(
)
usethis::use_mit_license("C:/Users/frkl.ECON/Documents/GitHub/ecic")
setwd("C:/Users/frkl.ECON/Documents/GitHub/ecic")
getwd()
usethis::use_mit_license()
devtools::check("C:/Users/frkl.ECON/Documents/GitHub/ecic")
devtools::check("C:/Users/frkl.ECON/Documents/GitHub/ecic")
